# Описание программного кода

Для реализации заданных требований был выбран технологий стек C# + WPF. Первый был выбран ввиду его нарастающей популярности
и простоты. WPF же был логичным выбором для написания приложения на Windows 10, как самый легкий и удобный фреймворк
с большой аудиторией.

## Как оно работает

Основная логика игры заложена в Game.cs. В объекте этого класса происходит инициализация всех переменных, установка
значений нулевого года и симуляция следующего года (шага). В качестве параметров одного из конструкторов Game принимает
GridWrapper. 

Это простая обертка над стандартным для WPF контейнером DataGrid. DataGrid -- класс из стандартной библиотеки WPF, 
позволяющий выводить данные в формате таблицы, что наиболее близко к изначальной формулировке задачи. GridWrapper -- это
специально написанная обертка, основная задача которой -- предоставлять удобный доступ к данным. Буквально, чтобы записать
что-либо или прочитать из ячейки нужно написать:

`gridWrapper[x][y]`, где х -- это id переменной, о чем будет ниже, y -- год

или

`gridWrapper[x].YearZ`, Z -- тоже год

С этой оберткой удалось упростить Game.cs и почти выделить его из логики WPF. Благодаря этому основыной код симуляции 
портируется всего с небольшими изменениями на любую другую платформу, в том чиле ASP.NET (Web)
или Xammarin (cross-platform mobile).

Остальной код фактически обеспечивает работу оболочки. EditDialog.cs и NotEditableDialog.cs -- обеспечивают изменение
инструментальных переменных текущего года и запрет на изменение других переменных. PlotDialog.cs -- окно, которое отображает
график отдельной переменной за все известные года.

Так же реализованы сохранение в файл и загрузка из файла. Фактически сохраняются все переменные, по всем годам, которые были
симулрованы к моменту сохранения. Загрузка заполняет эти данные в таблицу, и выставляет корректный год в соответствии с данными.

## Как работает сама симуляция

Вначале симуляция инициализирует все переменные в функцие `InitializeVariables()`. Там заполнаяются списки по каждому типу переменных --
константы, промежуточные переменные, инструментальные переменные, конечные переменные. Для каждой переменной задается ee имя и расшифровка.

Далее, в функции `PassVariablesToGrid()`, списки переменных передаются в DataGridWrapper. Для каждой переменной создается своя строка.
Так же каждой перемеенной присваевается внутрений id и сохраняется в словарь типа \<название переменной, id\>.

И в конце вызвается функция `SimulateZeroYear()`, которая для каждой переменной устанавливает значение нулевого года.

В процессе игры вызывается самая важная функция `SimulateStep()`, которая устроена следующим образом. 

`...`

`SetVar("NAT.DEBT", GetVar("NAT.DEBT", Step.Previous) + GetVar("BUDG.DEF.TOT", Step.Previous));`

`SetVar("NAT.DEBT.SER", GetVar("NAT.DEBT", Step.Previous) + GetVar("INTEREST.NR", Step.Current));`

`...`

В классе Game определены функции `void SetVar(string name, float value)` и `float GetVar(string name, Step step)`, которые получают у устанавливают значения соответсвтвенно. Параметр `Step` отвечает за то и какого года брать значение переменной -- симулируемого или предыдущего.

